#!/soft/general/python-3.1.3/bin/python3

#option parsing
import sys
from optparse import OptionParser

#file system
import os, os.path, glob, tempfile

#other
import subprocess

class Configuration:
	def __init__(self, config_f):
		try:
			with open(config_f,"r") as config_F:
				configuration=config_F.readlines()
				config_F.close()
		except (IOError, OSError) as err:
			print(err)
			exit(1)

		mode = -1
		self.time=False
		for line in configuration:
			if line[0] == '\n':
				continue
			if line[0] == '#':
				line=line[1:-1]
				if line == "general":
					mode=1
			else:
				if mode == 1:
					(tag, value) = line.split('=')
					if tag.strip() == "scripts_dir":
						self.scripts_dir = value.strip()
					if tag.strip() == "apps_dir":
						self.apps_dir = value.strip()
					if tag.strip() == "tcoffee_dir":
						self.tcoffee_dir = value.strip()
					if tag.strip() == "cluster":
						self.cluster = value.strip()
					if tag.strip() == "email4tcoffee":
						self.email4tcoffee = value.strip()

def run_on_ebi_cluster(command):
	print("run on ebi")
	print("Under implement")
	exit(1)

def run_on_crg_cluster(command):
	print("run on crg")
	print("Under implement")
	exit(1)
	
def produce_clusters(options, config):
	print("\n[STEP 1] cluster sequences into homolgous groups ... ")
	
	cluster_dir = "cluster"
	cluster_file= cluster_dir+"/cluster.txt"
	if not os.path.isdir(cluster_dir):
		os.mkdir(cluster_dir)
		
	aa_dir = "aa_fasta"
	if not os.path.isdir(aa_dir):
		os.mkdir(aa_dir)
		
	nn_dir = "nn_fasta"
	if not os.path.isdir(nn_dir):
		os.mkdir(nn_dir)
		
	t1 = os.times()
	if (not os.path.exists(cluster_file)):
	  command = ["step1_cluster-4-fasta", cluster_dir, options.aa_seq]
	  p = subprocess.Popen(command)
	  p.communicate() #now wait

	command = ["step2_cluster-2-fasta-4-seqFasta.pl", options.aa_seq, cluster_file, aa_dir]
	p = subprocess.call(command)
	command = ["step2_cluster-2-fasta-4-seqFasta.pl", options.nn_seq, cluster_file, nn_dir]
	p = subprocess.call(command)
	t2 = os.times()
	running_time=(t2[0] - t1[0]) + (t2[1] - t1[1]) #user time + system time
	
	F = open('timelog.csv', 'r+')
	F.write("cluster,"+str(running_time)+"\n")
	F.close()
	
def produce_alns(options, config):
	print("\n[STEP 3-1] perform alignment\n")
	aa_dir  = "aa_fasta"
	nn_dir  = "nn_fasta"
	aln_dir = "alns"
	cluster = config.cluster

	TCOFFEE_PAREMETER=['-multi_core', 'no', '+keep_name', '-output', 'fasta_aln']
	TCOFFEE_PAREMETER2=['-multi_core', 'no', '+keep_name', '-output', 'fasta_aln']
	if options.msa_met == "mcoffee":
		TCOFFEE_PAREMETER += ['-mode', 'mcoffee']
	elif options.msa_met == "fmcoffee":
		TCOFFEE_PAREMETER += ['-mode', 'fmcoffee']
	elif options.msa_met != "tcoffee":
	    print("[ERROR] unknow method for MSA " + options.msa_met)
	    sys.exit(0)

	if not os.path.isdir(aln_dir):
		os.mkdir(aln_dir)
		
	seq_list = []
	for file_name in glob.glob(os.path.join(aa_dir, "*.fasta")):
		name=os.path.basename(file_name)
		seq_list.append(name[:name.index(".")] )
	  
	for seq_name in seq_list:
	  aa_aln_f = os.path.join(aln_dir, seq_name+"_aa.fasta_aln")
	  nn_aln_f = os.path.join(aln_dir, seq_name+"_nn.fasta_aln")
	  
	  if (not os.path.exists(aa_aln_f)):
	    print (" align "+seq_name)
	    seq_f = os.path.join(aa_dir, seq_name + ".fasta")
	    command = ['t_coffee', seq_f] + TCOFFEE_PAREMETER + ['-outfile', aa_aln_f ]
          #  command = ['t_coffee', seq_f] + TCOFFEE_PAREMETER + ['-outfile', aa_aln_f, '-quiet', '&>', '/dev/null']
	    if cluster == "CRG":
			run_on_crg_cluster(command)
	    if cluster == "EBI":
		run_on_ebi_cluster(command)
	    if cluster == "local":
		p = subprocess.call(command)
		
	  if (not os.path.exists(nn_aln_f)):
	   # print("asdasdasdadddddddddddddddddddddddddddddd")
	    seq_f = os.path.join(nn_dir, seq_name + ".fasta")
	    command = 't_coffee -other_pg seq_reformat -in ' + seq_f + ' -in2 ' + aa_aln_f + ' -action +thread_dna_on_prot_aln -output fasta > ' + nn_aln_f
	 #   command = 't_coffee -other_pg=seq_reformat -in ' seq_f +  seq_f + ' -in2 ' +   nn_aln_f
	    if cluster == "CRG":
		run_on_crg_cluster(command)
	    if cluster == "EBI":
		run_on_ebi_cluster(command)
	    if cluster == "local":
		p = subprocess.call(command,shell=True)
		
	if (cluster == "CRG") | (cluster == "EBI"):
	  while (len(os.walk(aln_dir).next()[2]) < 2*len(seq_list)):
		print('.')
		time.sleep(5)
	  print('[DONE]\n')
	
	#remove dnd tree files generated by T-Coffee
	if (glob.glob('*.dnd')):
	  os.system('rm *.dnd')
	
	#perform concatenating alignment
	concate_aln_f = os.path.join(aln_dir, "concatenation.fasta_aln")
	if (not os.path.exists(concate_aln_f)):
	  print("[STEP 3-2] concatenate alignment")
	  command = ['step3-2_concateAlign', aln_dir, concate_aln_f]
	  subprocess.call(command)

def gen_phyml_cmd(aln_f, tree_f):
	temp_f   = tempfile.NamedTemporaryFile(delete=False)
	code_f   = temp_f.name+'.code'
	command1 = 't_coffee -other_pg seq_reformat -in ' + aln_f + ' -output code_name>' + code_f + '\n'
	command2 = 't_coffee -other_pg seq_reformat -code ' + code_f + ' -in ' + aln_f +' -output phylip > ' + temp_f.name + '\n'
	command3 = 'phyml -i ' +  temp_f.name + ' -b 0\n'
	command4 = 'postprocess-4-phyml.pl ' + temp_f.name + ' ' + tree_f
	return(command1 + command2 + command3 + command4)
	
def produce_trees(options, config):
	tree_met = options.tree_met
	cluster  = config.cluster
	
	aln_dir  = "alns"
	tree_dir = "trees"
	if not os.path.isdir(tree_dir):
		os.mkdir(tree_dir) 
	
	treeCon_f   = os.path.join(tree_dir, "concatenation.ph")
	treefinal_f = os.path.join(tree_dir, "final.ph")
	concate_f   = os.path.join("alns", "concatenation.fasta_aln")
	
	if (not os.path.exists(concate_f)):
	  print("[ERROR] $CONCATENATE_ALN does not exist")
	  sys.exit(0)
	elif (not os.path.exists(treeCon_f)):
	  print("[STEP 4-1] build tree for concatenate alignment\n")
	  if tree_met == "treebest":
		  command = 'treebest best -o '+ treeCon_f + ' ' + concate_f  
	  elif tree_met == "phyml":
		  command = gen_phyml_cmd(concate_f, treeCon_f)
	  else:
	      print("[ERROR] unknow method for MSA" + tree_met)
	      sys.exit(0)      
	  if cluster == "CRG":
		  run_on_crg_cluster(command)
	  elif cluster == "EBI":
		  run_on_ebi_cluster(command)
	  elif cluster == "local":
		  p = subprocess.Popen(command, shell=True)  
		  p.communicate() #now wait

	seq_list = []
	for file_name in glob.glob(os.path.join(aln_dir, "cluster*_nn.fasta_aln")):
		name=os.path.basename(file_name)
		seq_list.append(name[:name.index("_nn.fasta_aln")])
	
	for seq_name in seq_list:
	  aln_f = os.path.join(aln_dir, seq_name+"_nn.fasta_aln")
	  tree_f = os.path.join(tree_dir, seq_name+".ph")  
	  if (not os.path.exists(tree_f)):
	  	  print(' build tree = ' + tree_f)
		  if tree_met == "treebest":
		      command = 'treebest best -o '+ tree_f + ' ' + aln_f
		      if (options.species_tree): command += ' -f ' + options.species_tree
		  elif tree_met == "phyml":
		      command = gen_phyml_cmd(aln_f, tree_f)
		  else:
		    print("[ERROR] unknow method for MSA" + tree_met)
		    sys.exit(0)
		    
		  if cluster == "CRG":
		    run_on_crg_cluster(command)
		  elif cluster == "EBI":
		    run_on_ebi_cluster(command)
		  elif cluster == "local":
		    p = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE)
		    p.communicate() #now wait  
	
	#waiting for all process finish when submit jobs to queue
	if (cluster == "CRG") | (cluster == "EBI"):
	  while (len(os.walk(tree_dir).next()[2])-1 < len(seq_list)):
		print('.')
		time.sleep(5)
	  print('[DONE]\n')

	if (not os.path.exists(treefinal_f)):
	  command = ['mergeGroup2bigTree', treeCon_f, treefinal_f, tree_dir]
	  subprocess.call(command)

def initialization(options):
	config=Configuration(options.config_f)
	cwd = os.getcwd()
	
	options.aa_seq = os.path.join(cwd, options.aa_seq)
	options.nn_seq = os.path.join(cwd, options.nn_seq)
	if (options.species_tree): options.species_tree = os.path.join(cwd, options.species_tree)
	
	print("[INPUT]\n\tprotein seq="+options.aa_seq+"\n\tnuclear seq="+options.nn_seq+"\n")
	print("[OUTPUT]\n\tresult dic="+options.res_dir+"\n")
	print("[METHOD]\n\tMSA ="+options.msa_met+"\n\ttree="+options.tree_met+"\n")
	
	#add scripts and bin into PATH	
	scripts_dir=os.path.join(cwd, config.scripts_dir)
	apps_dir   =os.path.join(cwd, config.apps_dir)
	os.environ['PATH'] = os.environ['PATH']+':'+scripts_dir+':'+apps_dir
	
	#initialization of T-Coffee
	tcoffee_dir      =os.path.join(cwd, config.tcoffee_dir)
	tcoffee_bin_dir  =os.path.join(tcoffee_dir, 'bin')
	tcoffee_tmp_dir  =os.path.join(tcoffee_dir, 'tmp')
	tcoffee_cache_dir=os.path.join(tcoffee_dir, 'cache')
	tcoffee_lock_dir =os.path.join(tcoffee_dir, 'lock')
	
	os.putenv('DIR_4_TCOFFEE',     tcoffee_dir)
	os.putenv('TMP_4_TCOFFEE',     tcoffee_tmp_dir)
	os.putenv('LOCKDIR_4_TCOFFEE', tcoffee_lock_dir)
	os.putenv('CACHE_4_TCOFFEE',   tcoffee_cache_dir)
	os.putenv('EMAIL_4_TCOFFEE',   config.email4tcoffee)
	os.putenv('PATH', os.environ['PATH']+':'+tcoffee_bin_dir)
	
	command = ['mkdir','-p', tcoffee_dir, tcoffee_tmp_dir, tcoffee_cache_dir, tcoffee_lock_dir]
	subprocess.call(command)
	
	#make dir for result dic
	if not os.path.isdir(options.res_dir):
		os.mkdir(options.res_dir)
	os.chdir(options.res_dir)
	
	#check whether sequence is consistent between aa_seq and nn_seq
	analysis_dir = "analysis"
	if not os.path.isdir(analysis_dir):
		os.mkdir(analysis_dir)
	t1 = os.times()
	
	command = ['step0_check', options.aa_seq, options.nn_seq, analysis_dir]
	subprocess.call(command)
	t2 = os.times()
	running_time=(t2[0] - t1[0]) + (t2[1] - t1[1]) #user time + system time
	
	F = open('timelog.csv', 'w')
	F.write("step,time(s)\n")
	F.write("check,"+str(running_time)+"\n")
	F.close()
	return config
	
def production(options, config):
	#produces clusters
	if options.produce.rfind('c') != -1:
		produce_clusters(options, config)

	#produce alignments
	if options.produce.rfind('a') != -1:
		produce_alns(options, config)

	#produce trees
	if options.produce.rfind('t') != -1:
		produce_trees(options, config)
	
def main(argv):
	parser = parser = OptionParser()

	parser.add_option("--pro", 
					dest="aa_seq", metavar="FILE", help = "protein sequence")
	parser.add_option("--nn", 
					dest="nn_seq", metavar="FILE", help = "nuclear sequence")
	parser.add_option("-t", "--tree",
					dest="species_tree", metavar="FILE", help = "species tree")
	parser.add_option("-T", "--tree_met",
					dest="tree_met", default="treebest", help = "build tree method")
	parser.add_option("-M", "--msa_met",
					dest="msa_met", default="fmcoffee", help = "msa method")
	parser.add_option("-c", "--config_file",
					dest="config_f", help="Configuration file", metavar="FILE")
	parser.add_option("-p", "--produce",
					dest="produce", default="cat",
					help = "This option specifies procedures to run.\
					cat : cluster (c), alignment(a) and build tree (t) are performed.\
					at  : alignment and build tree are performed.\
					t   : build tree are performed.")
	parser.add_option("-r", "--res_dir",
					dest="res_dir", default="result_dir",
					help = "Dir for result")
		
	(options, args) = parser.parse_args()

	if (not options.config_f) or (not options.aa_seq) or (not options.nn_seq):
		parser.error('configure_file or protein_seq or nuclear_seq is missing')
		parser.print_help()
	else:
		config = initialization(options)
		production(options, config)

if __name__ == "__main__":
    main(sys.argv[1:])
